{"title":"JavaScript跨域总结与解决办法","date":"2015-04-16T13:00:00.000Z","slug":"javascript_cross-domain","tags":["Programing"],"categories":["Learning"],"updated":"2019-04-03T13:39:46.375Z","content":"<h1 id=\"JavaScript跨域总结与解决办法\">JavaScript跨域总结与解决办法<a href=\"post/javascript_cross-domain#JavaScript跨域总结与解决办法\"></a></h1><h3 id=\"1-什么是跨域\">1. 什么是跨域<a href=\"post/javascript_cross-domain#1-什么是跨域\"></a></h3><p>JavaScript出于安全方面的考虑，不允许跨域调用其他页面的对象。但在安全限制的同时也给注入iframe或是ajax应用上带来了不少麻烦。这里把涉及到跨域的一些问题简单地整理一下：</p>\n<p>首先什么是跨域，简单地理解就是因为JavaScript同源策略的限制，a.com 域名下的js无法操作b.com或是c.a.com域名下的对象。更详细的说明可以看下表：<br><img src=\"https://jjjie.github.io/../images/blog/domain_float.png?m=webp&q=80\" alt><br><strong>特别注意两点：</strong></p>\n<ol>\n<li>如果是协议和端口造成的跨域问题“前台”是无能为力的，</li>\n<li>在跨域问题上，域仅仅是通过“URL的首部”来识别而不会去尝试判断相同的ip地址对应着两个域或两个域是否在同一个ip上。</li>\n</ol>\n<p>“URL的首部”指window.location.protocol +window.location.host，也可以理解为“Domains, protocols and ports must match”。</p>\n<h3 id=\"2-document-domain-iframe的设置\">2. document.domain+iframe的设置<a href=\"post/javascript_cross-domain#2-document-domain-iframe的设置\"></a></h3><p>对于主域相同而子域不同的例子，可以通过设置document.domain的办法来解决。</p>\n<p>具体的做法是可以在<code>http://www.a.com/a.html</code>和<code>http://script.a.com/b.html</code>两个文件中分别加上<code>document.domain = ‘a.com’；</code></p>\n<p>然后通过a.html文件中创建一个iframe，去控制iframe的contentDocument，这样两个js文件之间就可以“交互”了。当然这种办法只能解决主域相同而二级域名不同的情况，如果你异想天开的把script.a.com的domian设为alibaba.com那显然是会报错地！代码如下：</p>\n<p><a href=\"http://www.a.com上的a.html\" target=\"_blank\" rel=\"noopener\">www.a.com上的a.html</a></p>\n<pre><code>document.domain = &apos;a.com&apos;;\nvar ifr = document.createElement(&apos;iframe&apos;);\nifr.src = &apos;http://script.a.com/b.html&apos;;\nifr.style.display = &apos;none&apos;;\ndocument.body.appendChild(ifr);\nifr.onload = function(){\n    var doc = ifr.contentDocument || ifr.contentWindow.document;\n    // 在这里操纵b.html\n    alert(doc.getElementsByTagName(&quot;h1&quot;)[0].childNodes[0].nodeValue);\n};\n</code></pre><p>script.a.com上的b.html</p>\n<pre><code>document.domain = &apos;a.com&apos;;\n</code></pre><p>这种方式适用于{<a href=\"http://www.kuqin.com\" target=\"_blank\" rel=\"noopener\">www.kuqin.com</a>, kuqin.com, script.kuqin.com, css.kuqin.com}中的任何页面相互通信。</p>\n<p>备注：某一页面的domain默认等于window.location.hostname。主域名是不带www的域名，例如a.com，主域名前面带前缀的通常都为二级域名或多级域名，例如<a href=\"http://www.a.com其实是二级域名。\" target=\"_blank\" rel=\"noopener\">www.a.com其实是二级域名。</a> domain只能设置为主域名，不可以在b.a.com中将domain设置为c.a.com。</p>\n<p>问题：</p>\n<ol>\n<li>安全性，当一个站点（b.a.com）被攻击后，另一个站点（c.a.com）会引起安全漏洞。</li>\n<li>如果一个页面中引入多个iframe，要想能够操作所有iframe，必须都得设置相同domain。</li>\n</ol>\n<h3 id=\"3-动态创建script\">3. 动态创建script<a href=\"post/javascript_cross-domain#3-动态创建script\"></a></h3><p>虽然浏览器默认禁止了跨域访问，但并不禁止在页面中引用其他域的JS文件，并可以自由执行引入的JS文件中的function（包括操作cookie、Dom等等）。根据这一点，可以方便地通过创建script节点的方法来实现完全跨域的通信。具体的做法可以参考YUI的Get Utility</p>\n<p>这里判断script节点加载完毕还是蛮有意思的：ie只能通过script的readystatechange属性，其它浏览器是script的load事件。以下是部分判断script加载完毕的方法。</p>\n<pre><code>js.onload = js.onreadystatechange = function() {\n    if (!this.readyState || this.readyState === &apos;loaded&apos; || this.readyState === &apos;complete&apos;) {\n        // readyState返回document的加载状态\n        // callback在此处执行\n        js.onload = js.onreadystatechange = null;\n    }\n};\n</code></pre><h3 id=\"4-利用iframe和location-hash\">4. 利用iframe和location.hash<a href=\"post/javascript_cross-domain#4-利用iframe和location-hash\"></a></h3><p>这个办法比较绕，但是可以解决完全跨域情况下的脚步置换问题。原理是利用location.hash（返回一个DOMString包含片段标识符“#”紧随其后的URL）来进行传值。</p>\n<ol>\n<li>在url： <a href=\"http://a.com#helloword中的‘#helloworld’就是location.hash，改变hash并不会导致页面刷新，所以可以利用hash值来进行数据传递，当然数据容量是有限的。\" target=\"_blank\" rel=\"noopener\">http://a.com#helloword中的‘#helloworld’就是location.hash，改变hash并不会导致页面刷新，所以可以利用hash值来进行数据传递，当然数据容量是有限的。</a></li>\n<li>假设域名a.com下的文件cs1.html要和cnblogs.com域名下的cs2.html传递信息，cs1.html首先创建自动创建一个隐藏的iframe，iframe的src指向cnblogs.com域名下的cs2.html页面，这时的hash值可以做参数传递用。</li>\n<li>cs2.html响应请求后再将通过修改cs1.html的hash值来传递数据（由于两个页面不在同一个域下IE、Chrome不允许修改parent.location.hash的值，所以要借助于a.com域名下的一个代理iframe；Firefox可以修改）。同时在cs1.html上加一个定时器，隔一段时间来判断location.hash的值有没有变化，一点有变化则获取获取hash值。代码如下：</li>\n</ol>\n<p>先是a.com下的文件cs1.html文件：</p>\n<pre><code>function startRequest(){\n    var ifr = document.createElement(&apos;iframe&apos;);\n    ifr.style.display = &apos;none&apos;;\n    ifr.src = &apos;http://www.cnblogs.com/lab/cscript/cs2.html#paramdo&apos;;\n    document.body.appendChild(ifr);\n}\n\nfunction checkHash() {\n    try {\n        var data = location.hash ? location.hash.substring(1) : &apos;&apos;;\n        if (console.log) {\n            console.log(&apos;Now the data is &apos;+data);\n        }\n    } catch(e) {};\n}\nsetInterval(checkHash, 2000);\n</code></pre><p>cnblogs.com域名下的cs2.html:</p>\n<pre><code>//模拟一个简单的参数处理操作\nswitch(location.hash){\n    case &apos;#paramdo&apos;:\n        callBack();\n        break;\n    case &apos;#paramset&apos;:\n        //do something……\n        break;\n}\n\nfunction callBack(){\n    try {\n        parent.location.hash = &apos;somedata&apos;;\n    } catch (e) {\n        // ie、chrome的安全机制无法修改parent.location.hash，\n        // 所以要利用一个中间的cnblogs域下的代理iframe\n        var ifrproxy = document.createElement(&apos;iframe&apos;);\n        ifrproxy.style.display = &apos;none&apos;;\n        ifrproxy.src = &apos;http://a.com/test/cscript/cs3.html#somedata&apos;;    // 注意该文件在&quot;a.com&quot;域下\n        document.body.appendChild(ifrproxy);\n    }\n}\n</code></pre><p>a.com下的域名cs3.html</p>\n<pre><code>//因为parent.parent和自身属于同一个域，所以可以改变其location.hash的值\nparent.parent.location.hash = self.location.hash.substring(1);\n</code></pre><p>当然这样做也存在很多缺点，诸如数据直接暴露在了url中，数据容量和类型都有限等……</p>\n<h3 id=\"5-window-name实现的跨域数据传输\">5. window.name实现的跨域数据传输<a href=\"post/javascript_cross-domain#5-window-name实现的跨域数据传输\"></a></h3><p>有三个页面：</p>\n<ul>\n<li>a.com/app.html：应用页面。</li>\n<li>a.com/proxy.html：代理文件，一般是一个没有任何内容的html文件，需要和应用页面在同一域下。</li>\n<li>b.com/data.html：应用页面需要获取数据的页面，可称为数据页面。<br>实现起来基本步骤如下：</li>\n</ul>\n<ol>\n<li><p>在应用页面（a.com/app.html）中创建一个iframe，把其src指向数据页面（b.com/data.html）。<br>数据页面会把数据附加到这个iframe的window.name上，data.html代码如下：</p>\n<pre><code>window.name = &apos;I was there!&apos;;\n// 这里是要传输的数据，大小一般为2M，IE和firefox下可以大至32M左右\n// 数据格式可以自定义，如json、字符串\n</code></pre></li>\n<li><p>在应用页面（a.com/app.html）中监听iframe的onload事件，在此事件中设置这个iframe的src指向本地域的代理文件（代理文件和应用页面在同一域下，所以可以相互通信）。app.html部分代码如下：</p>\n<pre><code>var state = 0,\n  iframe = document.createElement(&apos;iframe&apos;),\n  loadfn = function() {\n      if (state === 1) {\n          var data = iframe.contentWindow.name;    // 读取数据\n          alert(data);    //弹出&apos;I was there!&apos;\n      } else if (state === 0) {\n          state = 1;\n          iframe.contentWindow.location = &quot;http://a.com/proxy.html&quot;;    // 设置的代理文件\n      }  \n  };\n  iframe.src = &apos;http://b.com/data.html&apos;;\n  if (iframe.attachEvent) {\n      iframe.attachEvent(&apos;onload&apos;, loadfn);\n  } else {\n      iframe.onload  = loadfn;\n  }\n  document.body.appendChild(iframe);\n</code></pre></li>\n<li><p>获取数据以后销毁这个iframe，释放内存；这也保证了安全（不被其他域frame js访问）。</p>\n<pre><code>iframe.contentWindow.document.write(&apos;&apos;);\n  iframe.contentWindow.close();\n  document.body.removeChild(iframe);\n</code></pre></li>\n</ol>\n<p>总结起来即：iframe的src属性由外域转向本地域，跨域数据即由iframe的window.name从外域传递到本地域。这个就巧妙地绕过了浏览器的跨域访问限制，但同时它又是安全操作。</p>\n<h3 id=\"6-使用HTML5-postMessage\">6. 使用HTML5 postMessage<a href=\"post/javascript_cross-domain#6-使用HTML5-postMessage\"></a></h3><p>HTML5中最酷的新功能之一就是 跨文档消息传输Cross Document Messaging。下一代浏览器都将支持这个功能：Chrome 2.0+、Internet Explorer 8.0+, Firefox 3.0+, Opera 9.6+, 和 Safari 4.0+ 。 Facebook已经使用了这个功能，用postMessage支持基于web的实时消息传递。</p>\n<p><strong>otherWindow.postMessage(message, targetOrigin);</strong></p>\n<ul>\n<li>otherWindow: 对接收信息页面的window的引用。可以是页面中iframe的contentWindow属性；</li>\n<li>window.open的返回值；通过name或下标从window.frames取到的值。</li>\n<li>message: 所要发送的数据，string类型。</li>\n<li>targetOrigin: 用于限制otherWindow，<code>*</code>表示不作限制</li>\n</ul>\n<p>a.com/index.html中的代码：</p>\n<pre><code>&lt;iframe id=&quot;ifr&quot; src=&quot;b.com/index.html&quot;&gt;&lt;/iframe&gt;\n&lt;script type=&quot;text/javascript&quot;&gt;\nwindow.onload = function() {\n    var ifr = document.getElementById(&apos;ifr&apos;);\n    var targetOrigin = &apos;http://b.com&apos;;  // 若写成&apos;http://b.com/c/proxy.html&apos;效果一样\n                                        // 若写成&apos;http://c.com&apos;就不会执行postMessage了\n    ifr.contentWindow.postMessage(&apos;I was there!&apos;, targetOrigin);\n};\n&lt;/script&gt;\n</code></pre><p>b.com/index.html中的代码：</p>\n<pre><code>window.addEventListener(&apos;message&apos;, function(event){\n        // 通过origin属性判断消息来源地址\n        if (event.origin == &apos;http://a.com&apos;) {\n            alert(event.data);    // 弹出&quot;I was there!&quot;\n            alert(event.source);  // 对a.com、index.html中window对象的引用\n                                  // 但由于同源策略，这里event.source不可以访问window对象\n        }\n    }, false);\n</code></pre>","prev":{"title":"nc命令详解","slug":"nc_introduce"},"next":{"title":"H5动画60fps之路","slug":"H5_animation_60fps"},"link":"https://jjjie.github.io/blog/post/javascript_cross-domain/","toc":[{"title":"JavaScript跨域总结与解决办法","id":"JavaScript跨域总结与解决办法","index":"1"}]}