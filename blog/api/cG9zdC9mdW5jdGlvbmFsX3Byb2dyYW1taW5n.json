{"title":"函数式编程","date":"2015-04-05T13:00:00.000Z","slug":"functional_programming","tags":["Programing"],"categories":["Learning"],"updated":"2019-04-03T13:36:50.928Z","content":"<h1 id=\"函数式编程\">函数式编程<a href=\"post/functional_programming#函数式编程\"></a></h1><h3 id=\"1-概论\">1. 概论<a href=\"post/functional_programming#1-概论\"></a></h3><p>在过去的近十年的时间里，面向对象编程大行其道。以至于在大学的教育里，老师也只会教给我们两种编程模型，面向过程和面向对象。</p>\n<p>孰不知，在面向对象产生之前，在面向对象思想产生之前，函数式编程已经有了数十年的历史。</p>\n<p>那么，接下来，就让我们回顾这个古老又现代的编程模型，让我们看看究竟是什么魔力将这个概念，将这个古老的概念，在21世纪的今天再次拉入了我们的视野。</p>\n<h3 id=\"2-什么是函数式编程\">2. 什么是函数式编程<a href=\"post/functional_programming#2-什么是函数式编程\"></a></h3><p>在维基百科中，已经对函数式编程有了很详细的介绍。</p>\n<p>那我们就来摘取一下Wiki上对Functional Programming的定义：</p>\n<pre><code>In computer science, functional programming is a programming paradigm that treats computation as the evaluation of mathematical functions and avoids state and mutable data.\n</code></pre><p>简单地翻译一下，也就是说函数式编程是一种编程模型，他将<strong>计算机运算看做是数学中函数的计算，并且避免了状态以及变量的概念</strong>。</p>\n<p>接下来，我们就来剖析下函数式编程的一些特征。</p>\n<h3 id=\"3-从并发说开来\">3. 从并发说开来<a href=\"post/functional_programming#3-从并发说开来\"></a></h3><p>我们知道Erlang是一个支持高并发，有着强大容错性的函数式编程语言。</p>\n<p>在我眼里，Erlang对高并发的支持体现在两方面，第一，<strong>Erlang对轻量级进程的支持</strong>（请注意此处进程并不等于操作系统的进程，而只是Erlang内部的一个单位单元），第二，<strong>就是变量的不变性</strong>。</p>\n<h3 id=\"3-变量的不变性\">3. 变量的不变性<a href=\"post/functional_programming#3-变量的不变性\"></a></h3><p>让我们先来看两段程序，首先是我们常见的一种包含赋值的程序：</p>\n<pre><code>class Account:\n    def __init__(self,balance):\n        self.balance = balance\n    def desposit(self,amount):\n        self.balance = self.balance + amount\n        return self.balance\n    def despositTwice(self):\n        self.balance = self.balance * 2\n        return self.balance\n\nif __name__ == &apos;__main__&apos;:\n    account = Account(100)\n    print(account.desposit(10))\n    print(account.despositTwice())\n</code></pre><p>这段程序本身是没有问题的，但是我们考虑这样一种情况，现在有多个进程在同时跑这一个程序，那么程序就会被先desposit 还是先 despositTwice所影响。</p>\n<p>但是如果我们采用这样的方式：</p>\n<pre><code>def makeAccount(balance):\n    global desposit\n    global despositTwice\n    def desposit(amount):\n        result = balance + amount\n        return result\n    def despositTwice():\n        result = balance * 2\n        return result\n    def dispatch(method):\n        return eval(method)\n    return dispatch\n\nif __name__ == &apos;__main__&apos;:\n    handler = makeAccount(100)\n    print(handler(&apos;desposit&apos;)(10))\n    print(handler(&apos;despositTwice&apos;)())\n</code></pre><p>这时我们就会发现，无论多少个进程在跑，因为我们本身没有赋值操作，所以都不会影响到我们的最终结果。</p>\n<p>但是这样也像大家看到的一样，采用这样的方式没有办法保持状态。</p>\n<p>这也就是我们在之前概念中看到的无状态性。</p>\n<h3 id=\"4-函数式编程的第一型\">4. 函数式编程的第一型<a href=\"post/functional_programming#4-函数式编程的第一型\"></a></h3><p>我们知道，对象是面向对象的第一型，那么函数式编程也是一样，<strong>函数</strong>是函数式编程的第一型。</p>\n<p>在面向对象编程中，我们把对象传来传去，那在函数式编程中，我们要做的是把<strong>函数传来传去，而这个，说成术语，我们把他叫做高阶函数</strong>。</p>\n<p>那我们就来看一个高阶函数的应用，熟悉js的同学应该对下面的代码很熟悉，让哦我们来写一个在电子电路中常用的滤波器的示例代码。</p>\n<pre><code>def Filt(arr,func):\n    result = []\n    for item in arr:\n        result.append(func(item))\n    return result\n\ndef MyFilter(ele):\n    if ele &lt; 0 :\n        return 0\n    return ele\n\nif __name__ == &apos;__main__&apos;:\n    arr = [-5,3,5,11,-45,32]\n    print(&apos;%s&apos; % (Filt(arr,MyFilter)))\n</code></pre><p>哦，之前忘记了说，什么叫做高阶函数，我们给出定义：</p>\n<ol>\n<li>在数学和计算机科学中，高阶函数是至少满足下列一个条件的函数:</li>\n<li>接受一个或多个函数作为输入，输出一个函数</li>\n</ol>\n<p>那么，毫无疑问上面的滤波器，就是高阶函数的一种应用。</p>\n<p>在函数式编程中，函数是基本单位，是第一型，他几乎被用作一切，包括最简单的计算，甚至连变量都被计算所取代。在函数式编程中，变量只是一个名称，而不是一个存储单元，这是函数式编程与传统的命令式编程最典型的不同之处。</p>\n<p>让我们看看，变量只是一个名称，在上面的代码中，我们可以这样重写主函数：</p>\n<pre><code>if __name__ == &apos;__main__&apos;:\n    arr = [-5,3,5,11,-45,32]\n    func = MyFilter\n    print(&apos;%s&apos; % (Filt(arr,func)))\n</code></pre><p>当然，我们还可以把程序更精简一些，利用函数式编程中的利器，map,filter和reduce :</p>\n<pre><code>if __name__ == &apos;__main__&apos;:\n    arr = [-5,3,5,11,-45,32]\n    print(&apos;%s&apos; % (map(lambda x : 0 if x&lt;0 else x ,arr)))\n</code></pre><p>这样看上去是不是更赏心悦目呢？</p>\n<p>这样我们就看到了，函数是我们编程的基本单位。</p>\n<h3 id=\"5-函数式编程和递归\">5. 函数式编程和递归<a href=\"post/functional_programming#5-函数式编程和递归\"></a></h3><p>递归是函数式编程的一个重要的概念，循环可以没有，但是递归对于函数式编程却是不可或缺的。</p>\n<p>在这里，我得承认，我确实不知道我该怎么解释递归为什么对函数式编程那么重要。我能想到的只是递归充分地发挥了函数的威力，也解决了函数式编程无状态的问题。（如果大家有其他的意见，请赐教）</p>\n<p>递归其实就是将大问题无限地分解，直到问题足够小。</p>\n<p>而递归与循环在编程模型和思维模型上最大的区别则在于：</p>\n<blockquote>\n<ol>\n<li>循环是在描述我们该如何地去解决问题。</li>\n<li>递归是在描述这个问题的定义。</li>\n</ol>\n</blockquote>\n<p>那么就让我们以斐波那契数列为例来看下这两种编程模型。</p>\n<p>先说我们最常见的递归模型，这里，我不采用动态规划来做临时状态的缓存，只是说这种思路：</p>\n<pre><code>def Fib(a):\n    if a==0 or a==1:\n        return 1\n    else:\n        return Fib(a-2)+Fib(a-1)\n</code></pre><p>递归是在描述什么是斐波那契数列，这个数列的定义就是一个数等于他的前两项的和，并且已知Fib(0)和Fib(1)等于1。而程序则是用计算机语言来把这个定义重新描述了一次。</p>\n<p>那接下来，我们看下循环模型：</p>\n<pre><code>def Fib(n):\n    a=1\n    b=1\n    n = n - 1\n    while n&gt;0:\n        temp=a\n        a=a+b\n        b=temp\n        n = n-1\n    return b\n</code></pre><p>这里则是在描述我们该如何求解斐波那契数列，应该先怎么样再怎么样。</p>\n<p>而我们明显可以看到，递归相比于循环，具有着更加良好的可读性。</p>\n<h3 id=\"6-尾递归，伪递归\">6. 尾递归，伪递归<a href=\"post/functional_programming#6-尾递归，伪递归\"></a></h3><p>我们之前说到了递归和循环各自的问题，那怎么来解决这个问题，函数式编程为我们抛出了答案，尾递归。</p>\n<p>什么是尾递归，用最通俗的话说：<strong>就是在最后一部单纯地去调用递归函数</strong>，这里我们要注意“单纯”这个字眼。</p>\n<p>那么我们说下尾递归的原理，其实尾递归就是<strong>不要保持当前递归函数的状态，而把需要保持的东西全部用参数给传到下一个函数里，这样就可以自动清空本次调用的栈空间</strong>。这样的话，占用的栈空间就是常数阶的了。</p>\n<p>在看尾递归代码之前，我们还是先来明确一下递归的分类，我们将递归分成“树形递归”和“尾递归”，什么是树形递归，就是把计算过程逐一展开，最后形成的是一棵树状的结构，比如之前的斐波那契数列的递归解法。</p>\n<p>那么我们来看下斐波那契尾递归的写法：</p>\n<pre><code>def Fib(a,b,n):\n    if n==0:\n        return b\n    else:\n        return Fib(b,a+b,n-1)\n</code></pre><p>这里看上去有些难以理解，我们来解释一下：传入的a和b分别是前两个数，那么每次我都推进一位，那么b就变成了第一个数，而a+b就变成的第二个数。</p>\n<p>这就是尾递归。其实我们想一想，这不是在描述问题，而是在寻找一种问题的解决方案，和上面的循环有什么区别呢？我们来做一个从尾递归到循环的转换把！</p>\n<p>最后返回b是把，那我就先声明了，b=0</p>\n<p>要传入a是把，我也声明了，a=1</p>\n<p>要计算到n==0是把，还是循环while n!=0</p>\n<p>每一次都要做一个那样的计算是吧，我用临时变量交换一下。temp=b ; b=a+b;a=temp。</p>\n<p>那么按照这个思路一步步转换下去，是不是就是我们在上面写的那段循环代码呢？</p>\n<p>那么这个尾递归，其实本质上就是个“伪递归”，您说呢？</p>\n<p>既然我们可以优化，对于大多数的函数式编程语言的编译器来说，他们对尾递归同样提供了优化，使尾递归可以优化成循环迭代的形式，使其不会造成堆栈溢出的情况。</p>\n<h3 id=\"7-惰性求值与并行\">7. 惰性求值与并行<a href=\"post/functional_programming#7-惰性求值与并行\"></a></h3><p>我们看这样一段简单的代码：</p>\n<pre><code>def getResult():\n    a = getA()   //Take a long time\n    b = getB()   //Take a long time\n    c = a + b\n</code></pre><p>这段代码本身很简单，在命令式程序设计中，编译器（或解释器）会做的就是逐一解释代码，按顺序求出a和b的值，然后再求出c。</p>\n<p>可是我们从并行的角度考虑，求a的值是不是可以和求b的值并行呢？也就是说，直到执行到a+b的时候我们编译器才意识到a和b直到现在才需要，那么我们双核处理器就自然去发挥去最大的功效去计算了呢！</p>\n<p>这才是惰性求值的最大威力。</p>\n<p>当然，惰性求值有着这样的优点也必然有着缺点，我记得我看过一个例子是最经典的：</p>\n<pre><code>def Test():\n    print(&apos;Please enter a number:&apos;)\n    a = raw_input()\n</code></pre><p>可是这段代码如果惰性求值的话，第一句话就不见得会在第二句话之前执行了。</p>\n","prev":{"title":"git命令","slug":"git_command"},"next":{"title":"异步与同步","slug":"async&sync"},"link":"https://jjjie.github.io/blog/post/functional_programming/","toc":[{"title":"函数式编程","id":"函数式编程","index":"1"}],"copyright":{"author":"Wenjie Hu","link":"<a href=\"https://jjjie.github.io/blog/post/functional_programming/\" title=\"函数式编程\">https://jjjie.github.io/blog/post/functional_programming/</a>","license":"Attribution-NonCommercial-NoDerivatives 4.0 International (<a href=\"https://creativecommons.org/licenses/by-nc-sa/4.0/\" rel=\"external nofollow noopener\" target=\"_blank\">CC BY-NC-ND 4.0</a>)"}}