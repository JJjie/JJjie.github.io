{"title":"函数式编程","date":"2015-04-05T13:00:00.000Z","slug":"functional_programming","tags":["Programing"],"categories":["Learning"],"updated":"2019-04-05T07:41:58.030Z","content":"<h1 id=\"函数式编程\">函数式编程<a href=\"post/functional_programming#函数式编程\"></a></h1><h3 id=\"1-概论\">1. 概论<a href=\"post/functional_programming#1-概论\"></a></h3><p>在过去的近十年的时间里，面向对象编程大行其道。以至于在大学的教育里，老师也只会教给我们两种编程模型，面向过程和面向对象。</p>\n<p>孰不知，在面向对象产生之前，在面向对象思想产生之前，函数式编程已经有了数十年的历史。</p>\n<p>那么，接下来，就让我们回顾这个古老又现代的编程模型，让我们看看究竟是什么魔力将这个概念，将这个古老的概念，在21世纪的今天再次拉入了我们的视野。</p>\n<h3 id=\"2-什么是函数式编程\">2. 什么是函数式编程<a href=\"post/functional_programming#2-什么是函数式编程\"></a></h3><p>在维基百科中，已经对函数式编程有了很详细的介绍。</p>\n<p>那我们就来摘取一下Wiki上对Functional Programming的定义：</p>\n<pre><code>In computer science, functional programming is a programming paradigm that treats computation as the evaluation of mathematical functions and avoids state and mutable data.\n</code></pre><p>简单地翻译一下，也就是说函数式编程是一种编程模型，他将<strong>计算机运算看做是数学中函数的计算，并且避免了状态以及变量的概念</strong>。</p>\n<p>接下来，我们就来剖析下函数式编程的一些特征。</p>\n<h3 id=\"3-从并发说开来\">3. 从并发说开来<a href=\"post/functional_programming#3-从并发说开来\"></a></h3><p>我们知道Erlang是一个支持高并发，有着强大容错性的函数式编程语言。</p>\n<p>在我眼里，Erlang对高并发的支持体现在两方面，第一，<strong>Erlang对轻量级进程的支持</strong>（请注意此处进程并不等于操作系统的进程，而只是Erlang内部的一个单位单元），第二，<strong>就是变量的不变性</strong>。</p>\n<h3 id=\"3-变量的不变性\">3. 变量的不变性<a href=\"post/functional_programming#3-变量的不变性\"></a></h3><p>让我们先来看两段程序，首先是我们常见的一种包含赋值的程序：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">class Account:</span><br><span class=\"line\">    def __init__(self,balance):</span><br><span class=\"line\">        self.balance = balance</span><br><span class=\"line\">    def desposit(self,amount):</span><br><span class=\"line\">        self.balance = self.balance + amount</span><br><span class=\"line\">        return self.balance</span><br><span class=\"line\">    def despositTwice(self):</span><br><span class=\"line\">        self.balance = self.balance * 2</span><br><span class=\"line\">        return self.balance</span><br><span class=\"line\"></span><br><span class=\"line\">if __name__ == &apos;__main__&apos;:</span><br><span class=\"line\">    account = Account(100)</span><br><span class=\"line\">    print(account.desposit(10))</span><br><span class=\"line\">    print(account.despositTwice())</span><br></pre></td></tr></table></figure></p>\n<p>这段程序本身是没有问题的，但是我们考虑这样一种情况，现在有多个进程在同时跑这一个程序，那么程序就会被先desposit 还是先 despositTwice所影响。</p>\n<p>但是如果我们采用这样的方式：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">def makeAccount(balance):</span><br><span class=\"line\">    global desposit</span><br><span class=\"line\">    global despositTwice</span><br><span class=\"line\">    def desposit(amount):</span><br><span class=\"line\">        result = balance + amount</span><br><span class=\"line\">        return result</span><br><span class=\"line\">    def despositTwice():</span><br><span class=\"line\">        result = balance * 2</span><br><span class=\"line\">        return result</span><br><span class=\"line\">    def dispatch(method):</span><br><span class=\"line\">        return eval(method)</span><br><span class=\"line\">    return dispatch</span><br><span class=\"line\"></span><br><span class=\"line\">if __name__ == &apos;__main__&apos;:</span><br><span class=\"line\">    handler = makeAccount(100)</span><br><span class=\"line\">    print(handler(&apos;desposit&apos;)(10))</span><br><span class=\"line\">    print(handler(&apos;despositTwice&apos;)())</span><br></pre></td></tr></table></figure></p>\n<p>这时我们就会发现，无论多少个进程在跑，因为我们本身没有赋值操作，所以都不会影响到我们的最终结果。</p>\n<p>但是这样也像大家看到的一样，采用这样的方式没有办法保持状态。</p>\n<p>这也就是我们在之前概念中看到的无状态性。</p>\n<h3 id=\"4-函数式编程的第一型\">4. 函数式编程的第一型<a href=\"post/functional_programming#4-函数式编程的第一型\"></a></h3><p>我们知道，对象是面向对象的第一型，那么函数式编程也是一样，<strong>函数</strong>是函数式编程的第一型。</p>\n<p>在面向对象编程中，我们把对象传来传去，那在函数式编程中，我们要做的是把<strong>函数传来传去，而这个，说成术语，我们把他叫做高阶函数</strong>。</p>\n<p>那我们就来看一个高阶函数的应用，熟悉js的同学应该对下面的代码很熟悉，让哦我们来写一个在电子电路中常用的滤波器的示例代码。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">def Filt(arr,func):</span><br><span class=\"line\">    result = []</span><br><span class=\"line\">    for item in arr:</span><br><span class=\"line\">        result.append(func(item))</span><br><span class=\"line\">    return result</span><br><span class=\"line\"></span><br><span class=\"line\">def MyFilter(ele):</span><br><span class=\"line\">    if ele &lt; 0 :</span><br><span class=\"line\">        return 0</span><br><span class=\"line\">    return ele</span><br><span class=\"line\"></span><br><span class=\"line\">if __name__ == &apos;__main__&apos;:</span><br><span class=\"line\">    arr = [-5,3,5,11,-45,32]</span><br><span class=\"line\">    print(&apos;%s&apos; % (Filt(arr,MyFilter)))</span><br></pre></td></tr></table></figure></p>\n<p>哦，之前忘记了说，什么叫做高阶函数，我们给出定义：</p>\n<ol>\n<li>在数学和计算机科学中，高阶函数是至少满足下列一个条件的函数:</li>\n<li>接受一个或多个函数作为输入，输出一个函数</li>\n</ol>\n<p>那么，毫无疑问上面的滤波器，就是高阶函数的一种应用。</p>\n<p>在函数式编程中，函数是基本单位，是第一型，他几乎被用作一切，包括最简单的计算，甚至连变量都被计算所取代。在函数式编程中，变量只是一个名称，而不是一个存储单元，这是函数式编程与传统的命令式编程最典型的不同之处。</p>\n<p>让我们看看，变量只是一个名称，在上面的代码中，我们可以这样重写主函数：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">if __name__ == &apos;__main__&apos;:</span><br><span class=\"line\">    arr = [-5,3,5,11,-45,32]</span><br><span class=\"line\">    func = MyFilter</span><br><span class=\"line\">    print(&apos;%s&apos; % (Filt(arr,func)))</span><br><span class=\"line\">```\t</span><br><span class=\"line\"></span><br><span class=\"line\">当然，我们还可以把程序更精简一些，利用函数式编程中的利器，map,filter和reduce :</span><br></pre></td></tr></table></figure>\n<p>if <strong>name</strong> == ‘<strong>main</strong>‘:<br>    arr = [-5,3,5,11,-45,32]<br>    print(‘%s’ % (map(lambda x : 0 if x&lt;0 else x ,arr)))<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">这样看上去是不是更赏心悦目呢？</span><br><span class=\"line\"></span><br><span class=\"line\">这样我们就看到了，函数是我们编程的基本单位。</span><br><span class=\"line\"></span><br><span class=\"line\">### 5. 函数式编程和递归</span><br><span class=\"line\"></span><br><span class=\"line\">递归是函数式编程的一个重要的概念，循环可以没有，但是递归对于函数式编程却是不可或缺的。</span><br><span class=\"line\"></span><br><span class=\"line\">在这里，我得承认，我确实不知道我该怎么解释递归为什么对函数式编程那么重要。我能想到的只是递归充分地发挥了函数的威力，也解决了函数式编程无状态的问题。（如果大家有其他的意见，请赐教）</span><br><span class=\"line\"></span><br><span class=\"line\">递归其实就是将大问题无限地分解，直到问题足够小。</span><br><span class=\"line\"></span><br><span class=\"line\">而递归与循环在编程模型和思维模型上最大的区别则在于：</span><br><span class=\"line\"></span><br><span class=\"line\">&gt;1. 循环是在描述我们该如何地去解决问题。</span><br><span class=\"line\">&gt;2. 递归是在描述这个问题的定义。</span><br><span class=\"line\"></span><br><span class=\"line\">那么就让我们以斐波那契数列为例来看下这两种编程模型。</span><br><span class=\"line\"></span><br><span class=\"line\">先说我们最常见的递归模型，这里，我不采用动态规划来做临时状态的缓存，只是说这种思路：</span><br></pre></td></tr></table></figure></p>\n<p>def Fib(a):<br>    if a==0 or a==1:<br>        return 1<br>    else:<br>        return Fib(a-2)+Fib(a-1)<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">递归是在描述什么是斐波那契数列，这个数列的定义就是一个数等于他的前两项的和，并且已知Fib(0)和Fib(1)等于1。而程序则是用计算机语言来把这个定义重新描述了一次。</span><br><span class=\"line\"></span><br><span class=\"line\">那接下来，我们看下循环模型：</span><br></pre></td></tr></table></figure></p>\n<p>def Fib(n):<br>    a=1<br>    b=1<br>    n = n - 1<br>    while n&gt;0:<br>        temp=a<br>        a=a+b<br>        b=temp<br>        n = n-1<br>    return b<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">这里则是在描述我们该如何求解斐波那契数列，应该先怎么样再怎么样。</span><br><span class=\"line\"></span><br><span class=\"line\">而我们明显可以看到，递归相比于循环，具有着更加良好的可读性。</span><br><span class=\"line\"></span><br><span class=\"line\">### 6. 尾递归，伪递归</span><br><span class=\"line\"></span><br><span class=\"line\">我们之前说到了递归和循环各自的问题，那怎么来解决这个问题，函数式编程为我们抛出了答案，尾递归。</span><br><span class=\"line\"></span><br><span class=\"line\">什么是尾递归，用最通俗的话说：**就是在最后一部单纯地去调用递归函数**，这里我们要注意“单纯”这个字眼。</span><br><span class=\"line\"></span><br><span class=\"line\">那么我们说下尾递归的原理，其实尾递归就是**不要保持当前递归函数的状态，而把需要保持的东西全部用参数给传到下一个函数里，这样就可以自动清空本次调用的栈空间**。这样的话，占用的栈空间就是常数阶的了。</span><br><span class=\"line\"></span><br><span class=\"line\">在看尾递归代码之前，我们还是先来明确一下递归的分类，我们将递归分成“树形递归”和“尾递归”，什么是树形递归，就是把计算过程逐一展开，最后形成的是一棵树状的结构，比如之前的斐波那契数列的递归解法。</span><br><span class=\"line\"></span><br><span class=\"line\">那么我们来看下斐波那契尾递归的写法：</span><br></pre></td></tr></table></figure></p>\n<p>def Fib(a,b,n):<br>    if n==0:<br>        return b<br>    else:<br>        return Fib(b,a+b,n-1)<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">这里看上去有些难以理解，我们来解释一下：传入的a和b分别是前两个数，那么每次我都推进一位，那么b就变成了第一个数，而a+b就变成的第二个数。</span><br><span class=\"line\"></span><br><span class=\"line\">这就是尾递归。其实我们想一想，这不是在描述问题，而是在寻找一种问题的解决方案，和上面的循环有什么区别呢？我们来做一个从尾递归到循环的转换把！</span><br><span class=\"line\"></span><br><span class=\"line\">最后返回b是把，那我就先声明了，b=0</span><br><span class=\"line\"></span><br><span class=\"line\">要传入a是把，我也声明了，a=1</span><br><span class=\"line\"></span><br><span class=\"line\">要计算到n==0是把，还是循环while n!=0</span><br><span class=\"line\"></span><br><span class=\"line\">每一次都要做一个那样的计算是吧，我用临时变量交换一下。temp=b ; b=a+b;a=temp。</span><br><span class=\"line\"></span><br><span class=\"line\">那么按照这个思路一步步转换下去，是不是就是我们在上面写的那段循环代码呢？</span><br><span class=\"line\"></span><br><span class=\"line\">那么这个尾递归，其实本质上就是个“伪递归”，您说呢？</span><br><span class=\"line\"></span><br><span class=\"line\">既然我们可以优化，对于大多数的函数式编程语言的编译器来说，他们对尾递归同样提供了优化，使尾递归可以优化成循环迭代的形式，使其不会造成堆栈溢出的情况。</span><br><span class=\"line\"></span><br><span class=\"line\">### 7. 惰性求值与并行</span><br><span class=\"line\"></span><br><span class=\"line\">我们看这样一段简单的代码：</span><br></pre></td></tr></table></figure></p>\n<p>def getResult():<br>    a = getA()   //Take a long time<br>    b = getB()   //Take a long time<br>    c = a + b<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">这段代码本身很简单，在命令式程序设计中，编译器（或解释器）会做的就是逐一解释代码，按顺序求出a和b的值，然后再求出c。</span><br><span class=\"line\"></span><br><span class=\"line\">可是我们从并行的角度考虑，求a的值是不是可以和求b的值并行呢？也就是说，直到执行到a+b的时候我们编译器才意识到a和b直到现在才需要，那么我们双核处理器就自然去发挥去最大的功效去计算了呢！</span><br><span class=\"line\"></span><br><span class=\"line\">这才是惰性求值的最大威力。</span><br><span class=\"line\"></span><br><span class=\"line\">当然，惰性求值有着这样的优点也必然有着缺点，我记得我看过一个例子是最经典的：</span><br></pre></td></tr></table></figure></p>\n<p>def Test():<br>    print(‘Please enter a number:’)<br>    a = raw_input()<br><code>`</code><br>可是这段代码如果惰性求值的话，第一句话就不见得会在第二句话之前执行了。</p>\n","prev":{"title":"git命令","slug":"git_command"},"next":{"title":"异步与同步","slug":"async&sync"},"link":"https://vachelhu.github.io/blog/post/functional_programming/","toc":[{"title":"函数式编程","id":"函数式编程","index":"1"}],"copyright":{"author":"Wenjie Hu","link":"<a href=\"https://vachelhu.github.io/blog/post/functional_programming/\" title=\"函数式编程\">https://vachelhu.github.io/blog/post/functional_programming/</a>","license":"Attribution-NonCommercial-NoDerivatives 4.0 International (<a href=\"https://creativecommons.org/licenses/by-nc-sa/4.0/\" rel=\"external nofollow noopener\" target=\"_blank\">CC BY-NC-ND 4.0</a>)"}}