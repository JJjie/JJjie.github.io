# 函数式编程
### 1. 概论
在过去的近十年的时间里，面向对象编程大行其道。以至于在大学的教育里，老师也只会教给我们两种编程模型，面向过程和面向对象。

孰不知，在面向对象产生之前，在面向对象思想产生之前，函数式编程已经有了数十年的历史。

那么，接下来，就让我们回顾这个古老又现代的编程模型，让我们看看究竟是什么魔力将这个概念，将这个古老的概念，在21世纪的今天再次拉入了我们的视野。

### 2. 什么是函数式编程
在维基百科中，已经对函数式编程有了很详细的介绍。

那我们就来摘取一下Wiki上对Functional Programming的定义：

	In computer science, functional programming is a programming paradigm that treats computation as the evaluation of mathematical functions and avoids state and mutable data.

简单地翻译一下，也就是说函数式编程是一种编程模型，他将__计算机运算看做是数学中函数的计算，并且避免了状态以及变量的概念__。

接下来，我们就来剖析下函数式编程的一些特征。

### 3. 从并发说开来
我们知道Erlang是一个支持高并发，有着强大容错性的函数式编程语言。

在我眼里，Erlang对高并发的支持体现在两方面，第一，**Erlang对轻量级进程的支持**（请注意此处进程并不等于操作系统的进程，而只是Erlang内部的一个单位单元），第二，**就是变量的不变性**。

### 3. 变量的不变性
让我们先来看两段程序，首先是我们常见的一种包含赋值的程序：

	class Account:
	    def __init__(self,balance):
	        self.balance = balance
	    def desposit(self,amount):
	        self.balance = self.balance + amount
	        return self.balance
	    def despositTwice(self):
	        self.balance = self.balance * 2
	        return self.balance

	if __name__ == '__main__':
	    account = Account(100)
	    print(account.desposit(10))
	    print(account.despositTwice())

这段程序本身是没有问题的，但是我们考虑这样一种情况，现在有多个进程在同时跑这一个程序，那么程序就会被先desposit 还是先 despositTwice所影响。

但是如果我们采用这样的方式：

		def makeAccount(balance):
		    global desposit
		    global despositTwice
		    def desposit(amount):
		        result = balance + amount
		        return result
		    def despositTwice():
		        result = balance * 2
		        return result
		    def dispatch(method):
		        return eval(method)
		    return dispatch

		if __name__ == '__main__':
		    handler = makeAccount(100)
		    print(handler('desposit')(10))
		    print(handler('despositTwice')())


这时我们就会发现，无论多少个进程在跑，因为我们本身没有赋值操作，所以都不会影响到我们的最终结果。

但是这样也像大家看到的一样，采用这样的方式没有办法保持状态。

这也就是我们在之前概念中看到的无状态性。

### 4. 函数式编程的第一型
我们知道，对象是面向对象的第一型，那么函数式编程也是一样，**函数**是函数式编程的第一型。

在面向对象编程中，我们把对象传来传去，那在函数式编程中，我们要做的是把**函数传来传去，而这个，说成术语，我们把他叫做高阶函数**。

那我们就来看一个高阶函数的应用，熟悉js的同学应该对下面的代码很熟悉，让哦我们来写一个在电子电路中常用的滤波器的示例代码。

		def Filt(arr,func):
		    result = []
		    for item in arr:
		        result.append(func(item))
		    return result

		def MyFilter(ele):
		    if ele < 0 :
		        return 0
		    return ele

		if __name__ == '__main__':
		    arr = [-5,3,5,11,-45,32]
		    print('%s' % (Filt(arr,MyFilter)))


哦，之前忘记了说，什么叫做高阶函数，我们给出定义：

1. 在数学和计算机科学中，高阶函数是至少满足下列一个条件的函数:
2. 接受一个或多个函数作为输入，输出一个函数

那么，毫无疑问上面的滤波器，就是高阶函数的一种应用。

在函数式编程中，函数是基本单位，是第一型，他几乎被用作一切，包括最简单的计算，甚至连变量都被计算所取代。在函数式编程中，变量只是一个名称，而不是一个存储单元，这是函数式编程与传统的命令式编程最典型的不同之处。

让我们看看，变量只是一个名称，在上面的代码中，我们可以这样重写主函数：

		if __name__ == '__main__':
		    arr = [-5,3,5,11,-45,32]
		    func = MyFilter
		    print('%s' % (Filt(arr,func)))

当然，我们还可以把程序更精简一些，利用函数式编程中的利器，map,filter和reduce :

		if __name__ == '__main__':
		    arr = [-5,3,5,11,-45,32]
		    print('%s' % (map(lambda x : 0 if x<0 else x ,arr)))

这样看上去是不是更赏心悦目呢？

这样我们就看到了，函数是我们编程的基本单位。

### 5. 函数式编程和递归

递归是函数式编程的一个重要的概念，循环可以没有，但是递归对于函数式编程却是不可或缺的。

在这里，我得承认，我确实不知道我该怎么解释递归为什么对函数式编程那么重要。我能想到的只是递归充分地发挥了函数的威力，也解决了函数式编程无状态的问题。（如果大家有其他的意见，请赐教）

递归其实就是将大问题无限地分解，直到问题足够小。

而递归与循环在编程模型和思维模型上最大的区别则在于：

>1. 循环是在描述我们该如何地去解决问题。
>2. 递归是在描述这个问题的定义。

那么就让我们以斐波那契数列为例来看下这两种编程模型。

先说我们最常见的递归模型，这里，我不采用动态规划来做临时状态的缓存，只是说这种思路：

		def Fib(a):
		    if a==0 or a==1:
		        return 1
		    else:
		        return Fib(a-2)+Fib(a-1)

递归是在描述什么是斐波那契数列，这个数列的定义就是一个数等于他的前两项的和，并且已知Fib(0)和Fib(1)等于1。而程序则是用计算机语言来把这个定义重新描述了一次。

那接下来，我们看下循环模型：

		def Fib(n):
		    a=1
		    b=1
		    n = n - 1
		    while n>0:
		        temp=a
		        a=a+b
		        b=temp
		        n = n-1
		    return b

这里则是在描述我们该如何求解斐波那契数列，应该先怎么样再怎么样。

而我们明显可以看到，递归相比于循环，具有着更加良好的可读性。

### 6. 尾递归，伪递归

我们之前说到了递归和循环各自的问题，那怎么来解决这个问题，函数式编程为我们抛出了答案，尾递归。

什么是尾递归，用最通俗的话说：**就是在最后一部单纯地去调用递归函数**，这里我们要注意“单纯”这个字眼。

那么我们说下尾递归的原理，其实尾递归就是**不要保持当前递归函数的状态，而把需要保持的东西全部用参数给传到下一个函数里，这样就可以自动清空本次调用的栈空间**。这样的话，占用的栈空间就是常数阶的了。

在看尾递归代码之前，我们还是先来明确一下递归的分类，我们将递归分成“树形递归”和“尾递归”，什么是树形递归，就是把计算过程逐一展开，最后形成的是一棵树状的结构，比如之前的斐波那契数列的递归解法。

那么我们来看下斐波那契尾递归的写法：

		def Fib(a,b,n):
		    if n==0:
		        return b
		    else:
		        return Fib(b,a+b,n-1)

这里看上去有些难以理解，我们来解释一下：传入的a和b分别是前两个数，那么每次我都推进一位，那么b就变成了第一个数，而a+b就变成的第二个数。

这就是尾递归。其实我们想一想，这不是在描述问题，而是在寻找一种问题的解决方案，和上面的循环有什么区别呢？我们来做一个从尾递归到循环的转换把！

最后返回b是把，那我就先声明了，b=0

要传入a是把，我也声明了，a=1

要计算到n==0是把，还是循环while n!=0

每一次都要做一个那样的计算是吧，我用临时变量交换一下。temp=b ; b=a+b;a=temp。

那么按照这个思路一步步转换下去，是不是就是我们在上面写的那段循环代码呢？

那么这个尾递归，其实本质上就是个“伪递归”，您说呢？

既然我们可以优化，对于大多数的函数式编程语言的编译器来说，他们对尾递归同样提供了优化，使尾递归可以优化成循环迭代的形式，使其不会造成堆栈溢出的情况。

### 7. 惰性求值与并行

我们看这样一段简单的代码：

		def getResult():
		    a = getA()   //Take a long time
		    b = getB()   //Take a long time
		    c = a + b

这段代码本身很简单，在命令式程序设计中，编译器（或解释器）会做的就是逐一解释代码，按顺序求出a和b的值，然后再求出c。

可是我们从并行的角度考虑，求a的值是不是可以和求b的值并行呢？也就是说，直到执行到a+b的时候我们编译器才意识到a和b直到现在才需要，那么我们双核处理器就自然去发挥去最大的功效去计算了呢！

这才是惰性求值的最大威力。

当然，惰性求值有着这样的优点也必然有着缺点，我记得我看过一个例子是最经典的：

		def Test():
		    print('Please enter a number:')
		    a = raw_input()

可是这段代码如果惰性求值的话，第一句话就不见得会在第二句话之前执行了。
